#!/usr/bin/env python
"""
Take txt output of multiple sequence alignment between PDBs as generated by EBIfold SSM server
(http://www.ebi.ac.uk/msd-srv/ssm/) and output label files to use with getcontacts.
"""

import argparse

COLOR_MAP = {'helix': 'red', 'sheet': 'blue', 'none': ''}


def output_labelfiles(output_prefix, pdbs, alignments):
    output_prefix = output_prefix if output_prefix[-1] == '/' else output_prefix + '/'
    for pdb in pdbs:
        output_filename = output_prefix + pdb + '_labels.tsv'
        with open(output_filename, 'w+') as write_file:
            print("Writing %s" % output_filename)
            for label, alignment in enumerate(alignments):
                if pdb not in alignment:
                    continue
                else:
                    residue = alignment[pdb]
                    write_file.write("%s\n" % '\t'.join([residue['res'],
                                                         str(label), COLOR_MAP[residue['ss']]]))


def parse_alignmentline(alignmentline, pdbs):
    """ Given a line from SSM txt output with alignment between residues,
    return a dict from PDB to residue and secondary structure

    Input:
    alignmentline: Should look something like '  13 |h|a:val  25 | |h|a:val  67 | |h|a:ile  26 | |h|a:met  32 |'
    pdbs: list of PDBs in the order that they appear in the alignment line

    Output:
    alignment: dict from pdb to residue and secondary structure of the residue
    """
    alignment = {}
    alignmentline = alignmentline.strip().replace('|*|', '| |')
    startpos = alignmentline.find('|') + 1
    for i, pdb in enumerate(pdbs):
        if i == len(pdbs) - 1:
            endpos = len(alignmentline) - 2
        else:
            endpos = alignmentline[startpos:].find('| |') + startpos
        residue = alignmentline[startpos:endpos].strip()
        startpos = endpos + 3
        if ':' not in residue:
            continue
        if residue.lower()[0] == 'h':
            secondary_structure = 'helix'
        elif residue.lower()[0] == 's':
            secondary_structure = 'sheet'
        else:
            secondary_structure = 'none'
        chain, aa_resnum = residue.split(':')
        aa_resnum = aa_resnum.replace(' ', '')
        alignment[pdb] = {"res": (chain[-1] + ':' + aa_resnum[:3] + ':' + aa_resnum[3:]), "ss": secondary_structure}
    return alignment


def extract_alignments(input_filelines, pdbs):
    """ Given a list of lines from SSM output txt and list of PDBs in the SSM output,
    returns two dicts containing aligned residues; one of low-confidence alignments
    and one of high-confidence alignments

    The input file should have a range of lines that looks like this:

    >  3D ALIGNMENT OF BACKBONE ATOMS

    >-----+------------+-+------------+-+------------+-+------------+
    > ## |    5cxv    | |    4u15    | |    3uon    | |    5dsg    |
    >-----+------------+-+------------+-+------------+-+------------+
    >   1 |            | |            | |            | | |a:gly  20 |
    >   2 |            | |            | |            | | |a:pro  21 |
    >   3 |            | |            | |            | | |a:ser  22 |
    >   4 |            | |            | |            | | |a:ser  23 |
    >   5 |            | |            | |            | | |a:his  24 |
    >   6 |            | |            | |            | |h|a:asn  25 |
    >   7 |            | |            | | |a:thr  20 | |h|a:arg  26 |
    >   8 | |a:lys  20 | |            | | |a:phe  21 | |h|a:tyr  27 |
    >   9 |h|a:gly  21 | | |a:thr  63 | |h|a:glu  22 | |h|a:glu  28 |
    >  10 |h|a:pro  22 | |h|a:ile  64 | |h|a:val  23 | |h|a:thr  29 |
    >  11 |h|a:trp  23 | |h|a:trp  65 | |h|a:val  24 | |h|a:val  30 |
    >  12 |h|a:gln  24 | |h|a:gln  66 | |h|a:phe  25 | |h|a:glu  31 |
    >  13 |h|a:val  25 | |h|a:val  67 | |h|a:ile  26 | |h|a:met  32 |
    >  14 |h|a:ala  26 | |h|a:val  68 | |h|a:val  27 | |h|a:val  33 |
    >  15 |h|a:phe  27 | |h|a:phe  69 | |h|a:leu  28 | |h|a:phe  34 |
      .....
      .....
      .....
    >-----+------------+-+------------+-+------------+-+------------+

    """
    hiconf_alignments = []
    loconf_alignments = []
    # Identify start of alignment
    for idx in range(len(input_filelines)):
        fileline = input_filelines[idx]
        if "3D ALIGNMENT OF BACKBONE ATOMS" in fileline:
            break
    for jdx in range(idx + 4, len(input_filelines)):
        fileline = input_filelines[jdx]
        if '+' in fileline:
            break
        alignment = parse_alignmentline(fileline.upper(), pdbs)
        # High confidence alignment lines are upper-cased, while low confidence
        # alignments are lower-cased in the input
        if fileline.upper() == fileline:
            hiconf_alignments.append(alignment)
        else:
            loconf_alignments.append(alignment)
    return hiconf_alignments, loconf_alignments


def extract_pdbs(input_filelines):
    """ Given a list of lines from SSM output txt, returns a list of upper case PDBs

    The input file should have a range of lines enumerating the PDBS that looks like this:
     .....
     .....
      ##    Structure                        Nres  Nsse   RMSD  Q-score
   1  PDB 5cxv:A  .....................   444   20   2.2026  0.1449
   2  PDB 4u15:A  .....................   391   16   4.0164  0.0907
   3  PDB 3uon:A  .....................   438   20   3.8998  0.0840
   4  PDB 5dsg:A  .....................   392   17   1.9210  0.1791

     Number of aligned residues 99
     .....
     .....
    """
    pdbs = []
    # Find idx, which is the index of the line in SSM output before the line with PDB's
    for idx in range(len(input_filelines)):
        fileline = input_filelines[idx]
        # idx has the string "Nres" in it
        if "Nres" in fileline:
            break
    for jdx in range(idx+1, len(input_filelines)):
        fileline = input_filelines[jdx]
        if "Number" in fileline:
            break
        # '1  PDB 5cxv:A  .....................   444   20   2.2026  0.1449' converted to '5CXV'
        pdb = fileline.split()[2].upper()[:4]
        pdbs.append(pdb)
    return pdbs


def get_filelines(filename):
    """ Returns a list of all stripped non-empty lines in filename in order
    """
    print("Parsing SSM file %s" % filename)
    with open(filename, 'r') as read_file:
        filelines = read_file.readlines()
    filelines = [line.strip() for line in filelines if len(line.strip()) > 0]
    return filelines


def main(argv=None):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--ssm_filename',
                        required=True,
                        help="Path to a .dat output file generated by SSM's multiple sequence alignment tool")
    parser.add_argument('--output_dir',
                        required=False,
                        default='./',
                        help="Directory where label files will be written")
    parser.add_argument('--include_loconf',
                        type=bool,
                        required=False,
                        default=False,
                        help="Include residues aligned with low confidence in label files (default: False)")
    args = parser.parse_args(argv)

    input_filelines = get_filelines(args.ssm_filename)
    pdbs = extract_pdbs(input_filelines)
    hiconf_alignments, loconf_alignments = extract_alignments(input_filelines, pdbs)
    alignments = loconf_alignments + hiconf_alignments if args.include_loconf else hiconf_alignments
    output_labelfiles(args.output_dir, pdbs, alignments)


if __name__ == '__main__':
    main()

__author__ = 'Augustine Chemparathy <agchempa@gmail.com>'
__license__ = "Apache License 2.0"
