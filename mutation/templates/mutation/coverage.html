{% extends "home/base.html" %}

{% block addon_css %}
<style>
.node circle {
  /*fill: #fff;*/
  /*stroke: DarkGreen;*/
  /*fill: DarkGreen;*/
  stroke: #000000 ;
  stroke-width: .3px;
}

.node {
  font: 8px sans-serif;
}

.link {
  fill: none;
  stroke: #eee;
  stroke-width: 1px;
}

.node text {
  font: 8px sans-serif;
}

.links {
  fill: none;
  stroke: #000;
}

.link-extensions {
  fill: none;
  stroke: #000;
  stroke-opacity: .25;
}

</style>
{% endblock %}
{% block addon_js %}
<script  type="text/javascript" charset="utf-8" src="//d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" charset="utf-8">



interactions =  {"name":"GPCRs", "children":[ {"children": [{"name": "Aminergic receptors"}, {"name": "Peptide receptors"}, {"name": "Protein receptors"}, {"name": "Lipid receptors"}, {"name": "Melatonin receptors"}, {"name": "Nucleotide receptors"}, {"name": "Steroid receptors"}, {"name": "Alicarboxylic acid receptors"}, {"name": "Sensory receptors"}, {"name": "Orphan receptors"}, {"name": "Other"}], "name": "Class A (Rhodopsin)"}, {"children": [{"name": "Peptide receptors"}], "name": "Class B1 (Secretin)"}, {"children": [{"name": "Orphan receptors"}], "name": "Class B2 (Adhesion)"}, {"children": [{"name": "Ion receptors"}, {"name": "Amino acid receptors"}, {"name": "Sensory receptors"}, {"name": "Orphan receptors"}], "name": "Class C (Glutamate)"}, {"children": [{"name": "Protein receptors"}], "name": "Class F (Frizzled)"}, {"children": [{"name": "Orphan receptors"}], "name": "Other GPCRs"} ] };

interactions = {{ tree|safe }};

// Like d3.svg.diagonal.radial, but with square corners.
function step(startAngle, startRadius, endAngle, endRadius) {
  var c0 = Math.cos(startAngle = (startAngle - 90) / 180 * Math.PI),
      s0 = Math.sin(startAngle),
      c1 = Math.cos(endAngle = (endAngle - 90) / 180 * Math.PI),
      s1 = Math.sin(endAngle);
  return "M" + startRadius * c0 + "," + startRadius * s0
      + (endAngle === startAngle ? "" : "A" + startRadius + "," + startRadius + " 0 0 " + (endAngle > startAngle ? 1 : 0) + " " + startRadius * c1 + "," + startRadius * s1)
      + "L" + endRadius * c1 + "," + endRadius * s1;
}

var color = d3.scale.category20();

var diameter = 1300;

var tree = d3.layout.tree()
    .size([360, diameter / 2 - 120])
    .sort(function(a,b) { return b.sort - a.sort; })
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
    // .separation(function(a, b) { return ((a.parent == root) && (b.parent == root)) ? 3 : 1; });

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) { return [d.y, d.x / 180 * Math.PI]; });

var svg = d3.select("#svg").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
    .append("g")
    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

var nodes = tree.nodes(interactions)
      

    nodes.forEach(function(d) { 
    if (d.depth == 0) {
        d.y =  0
      } else if (d.depth == 1) {
        d.y =  180
      } else if (d.depth == 2  ) {
        d.y =  350
      } else if (d.depth == 3  ) {
        d.y =  500
      } else if (d.depth == 4  ) {
        d.y =  535
      }  else {
        d.y =  d.depth*150
      }
    });

var links = tree.links(nodes);

var link = svg.append("g")
      .attr("class", "links")
    .selectAll("path")
      .data(links)
    .enter().append("path")
      .each(function(d) { d.target.linkNode = this; })
      .attr("d", function(d) { return step(d.source.x, d.source.y, d.target.x, d.target.y) })
      .style("stroke", function(d) { return d.target.color; })
      .style("stroke-width", function(d) { if (d.target.depth>0) {return 5-d.target.depth;} else { return 0;} })
      .style("opacity", function(d) {
          if ((d.target.interactions > 0 && d.target.mutations_an > 0) || 1==1) {return 0.8 } //|| 1==1
          else if (d.target.interactions > 0) {return 0.5 }
          else if (d.target.mutations_an > 0) {return 0.5 }
          else {return 0.1}; });


 /// The more fluid version
  // var link = svg.selectAll(".link")
  //     .data(links)
  //     .enter().append("path")
  //     .attr("class", "link")
  //     .attr("d", diagonal)
  //     .style("stroke", function(d) { return d.target.color; })
  //     .style("stroke-width", function(d) { if (d.target.depth>0) {return 17-d.target.depth*d.target.depth;} else { return 0;} })
  //     .style("opacity", function(d) {
  //         if ((d.target.interactions > 0 && d.target.mutations_an > 0) || 1==1) {return 0.8 } //|| 1==1
  //         else if (d.target.interactions > 0) {return 0.5 }
  //         else if (d.target.mutations_an > 0) {return 0.5 }
  //         else {return 0.1}; })

  var node = svg.selectAll(".node")
      .data(nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { if (d.name=='GPCRs' ) {return "rotate(" + (d.x) + ")translate(" + d.y + ")";} else { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; } })

  node.filter(function(d) {return (d.depth==4)}).append("circle")
      .attr("r", function(d) { if (d.name=='GPCRs' ) {return "0"} else { return "4.5" } })
      .style("fill", function(d) {
          if (d.color && d.depth<5) {return d.color } 
          else if (d.interactions > 0 && d.mutations_an > 0) {return "FireBrick" }
          else if (d.interactions > 0) {return "Olive" }
          else if (d.mutations_an > 0) {return "Chocolate" }
          else {return "#ddd"}; })
      .style("opacity",0.6);

  node.append("text")
      .attr("dy", ".31em")
      .attr("text-anchor", function(d) { return d.x < 180 ? "end" : "start"; })
      .attr("transform", function(d) { if (d.depth==4) {
            return d.x < 180 ? "translate(30)" : "rotate(180)translate(-30)";
        } else {
            return d.x < 180 ? "translate(-12)" : "rotate(180)translate(12)";
        }
         })
      .text(function(d) { if (d.depth>0) { return d.name;} else { return ""; } })
      .style("font-size", function(d) { if (d.depth<3) {return "12px"} else { return "8px" } })
      .style("fill", function(d) {
          if (d.color) {return "#111" } 
          else if (d.interactions > 0 && d.mutations_an > 0 && 1==2) {return "green" }
          else if (d.interactions > 0 && 1==2) {return "Olive" }
          else if (d.mutations_an > 0 && 1==2) {return "palegreen" }
          else {return "#222"}; }).call(getBB);
  node.filter(function(d) {return (d.depth!=4)}).insert("rect","text")
    .attr("x", function(d){return d.x < 180 ? d.bbox.x-12 : d.bbox.x-d.bbox.width-12; })
    .attr("y", function(d){return d.bbox.y})
    .attr("width", function(d){return d.bbox.width})
    .attr("height", function(d){return d.bbox.height})
    .style("fill", "#FFF");

function getBB(selection) {
    selection.each(function(d){d.bbox = this.getBBox();})
}
 


function getAngle(d) {
    // Offset the angle by 90 deg since the '0' degree axis for arc is Y axis, while
    // for text it is the X axis.
    var thetaDeg = (180 / Math.PI * (arc.startAngle()(d) + arc.endAngle()(d)) / 2 - 90);
    // If we are rotating the text by more than 90 deg, then "flip" it.
    // This is why "text-anchor", "middle" is important, otherwise, this "flip" would
    // a little harder.
    return (thetaDeg > 90) ? thetaDeg - 180 : thetaDeg;
}


// Stash the old values for transition.
function stash(d) {
  d.x0 = d.x;
  d.dx0 = d.dx;
}

// Interpolate the arcs in data space.
function arcTween(a) {
  var i = d3.interpolate({x: a.x0, dx: a.dx0}, a);
  return function(t) {
    var b = i(t);
    a.x0 = b.x;
    a.dx0 = b.dx;
    return arc(b);
  };
}

//////////////////////////////

var color = d3.scale.category20c();

var width = 1100,
      height = 1100,
      radius = Math.min(width, height) / 2 - 10;

    var x = d3.scale.linear()
      .range([0, 2 * Math.PI]);

    var y = d3.scale.linear()
      .range([0, radius]);
      // console.log(y(0),y(1),y(radius))

    var svg = d3.select("#svg3")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("id", "scan")
      .attr("transform", "translate(" + width / 2 + "," + (height / 2) + ")");

    var partition = d3.layout.partition()
      .sort(function(a,b) { return b.sort - a.sort; })
      // .value(function(d) { if (d.depth!=4) {return d.receptor_i+d.receptor_m_an;} else { return Math.min(1,d.receptor_i+d.receptor_m_an); } });
      .value(function(d) { return d.receptor_t });

    var arc = d3.svg.arc()
      .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })
      .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })
      .innerRadius(function(d) { 

        // console.log("inner" + d.y+" "+Math.max(0, y(d.y))); return Math.max(0, y(d.y)); 
        if (d.y<0.3) {
            return 30;
        } else if (d.y<0.5) {
            return 150;
        } else if (d.y<0.7) {
            return 150+(radius-45-150)*0.4;
        } else if (d.y<0.9) {
            return radius-45;
        }

  })
      .outerRadius(function(d) { 
        
        // console.log("outer" + d.y+" "+Math.max(0, y(d.y + d.dy))); return Math.max(0, y(d.y + d.dy));
        if (d.y<0.3) {
            return 150;
        } else if (d.y<0.5) {
            return 150+(radius-45-150)*0.4;
        } else if (d.y<0.7) {
            return radius-45;
        } else if (d.y<0.9) {
            return radius-35;
        }
         });

var path = svg.datum(interactions).selectAll("path")
      .data(partition.nodes)
      .enter().append("g")
        
  path.append("path")
      .attr("display", function(d) { return d.depth ? null : "none"; }) // hide inner ring
      .attr("d", arc)
      .style("stroke", "#fff")
      .style("fill", function(d) {
          if (d.color && d.depth<4 ){ return d.color } //&& d.depth<4 && 1==2
          else if (d.interactions > 0 && d.mutations_an > 0) {return "FireBrick" }
          else if (d.interactions > 0) {return "Olive" }
          else if (d.mutations_an > 0) {return "Chocolate" }
          else {return "#ddd"}; })
      // .style("fill", function(d) { return color((d.children ? d : d.parent).name); })
      .style("opacity", function(d) {
          if ((d.interactions > 0 && d.mutations_an > 0) ) {return 0.9 } // || 1==1
          else if (d.interactions > 0) {return 0.6 }
          else if (d.mutations_an > 0) {return 0.6 }
          else {return 0.2}; })
      .style("fill-rule", "evenodd")
      .each(stash);

  function a(t) {
        return .299 * t.r + .587 * t.g + .114 * t.b
    }
  function n(t) {
        if (t.children) {
            var e = t.children.map(n),
                r = d3.hsl(e[0]),
                a = d3.hsl(e[1]);
            return d3.hsl((r.h + a.h) / 2, 1.2 * r.s, r.l / 1.2)
        }
        return t.colour || "#fff"
    }

      var i = radius*2,
        l = i,
        o = i / 2,
        d = d3.scale.linear().range([0, 2 * Math.PI]),
        u = d3.scale.pow().exponent(1.3).domain([0, 1]).range([0, o]),
        c = 5,
        s = 1e3


  path.append("text")
        .text(function(d) { 
            if ( d.receptor_i+d.receptor_m_an>0) {
                return d.name 
            } else if (1==1) { //if showing all
                return d.name
            }
        })
        .classed("label", true)
        .attr("x", function(d) { if (d.depth==4) { return d.x;} else {return d.x; } })
        // .attr("text-anchor", "end")
        .attr("text-anchor", function(d) { 
            // console.log(d.name+ " "+arc.centroid(d));
            if (d.depth==4) { 
                return arc.centroid(d)[0] < 0 ? "start" : "end"; 
            } else if (d.depth>0) {
                return arc.centroid(d)[0] < 0 ? "start" : "end"; 
            } else {
                return "middle";
            }
            })
        // translate to the desired point and set the rotation
        .attr("transform", function(d) {
            if (d.depth > 0 && d.depth<4) {
                return "translate(" + arc.centroid(d) + ")" +
                       "rotate(" + getAngle(d) + ")";
            }  else if (d.depth == 4) {
                // return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; 
                return "translate(" + arc.centroid(d) + ")" +
                       "rotate(" + getAngle(d) + ")";
            }  else {
                return null;
            }
        })
        // .attr("dx", "1") // margin
         .attr("dx", function(d) {if (d.depth==4) { return arc.centroid(d)[0] < 0 ? "-35px" : "35px";
                                    } else if (d.depth==1) { return arc.centroid(d)[0] < 0 ? "-55px" : "55px";
                                    } else if (d.depth==2) { return arc.centroid(d)[0] < 0 ? "-65px" : "65px";
                                    } else if (d.depth==3) { return arc.centroid(d)[0] < 0 ? "-80px" : "80px";
                                    } else { return "0px"; } } ) // vertical-align
         .attr("dy", ".35em") // vertical-align
        .attr("pointer-events", "none")
        .style("font","10px sans-serif")
        // .style("fill", function(d) {
        //   if (d.interactions > 0 && d.mutations_an > 0) {return "green" }
        //   else if (d.interactions > 0) {return "Olive" }
        //   else if (d.mutations_an > 0) {return "palegreen" }
        //   else {return "#ddd"}; });


/////////////////

var margin = {top: 20, right: 120, bottom: 20, left: 120},
    width = 960 - margin.right - margin.left,
    height = 800 - margin.top - margin.bottom;

var i = 0,
    duration = 750,
    root;

var diameter = 1300;

var tree = d3.layout.tree()
    .size([360, diameter / 2 - 120])
    .sort(function(a,b) { return b.sort - a.sort; })
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
    // .separation(function(a, b) { return ((a.parent == root) && (b.parent == root)) ? 3 : 1; });

var diagonal = d3.svg.diagonal.radial()
    .projection(function(d) { return [d.y, d.x / 180 * Math.PI]; });


var svg = d3.select("#svg2").append("svg")
    .attr("width", diameter)
    .attr("height", diameter)
    .append("g")
    .attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

  root = interactions;
  root.x0 = height / 2;
  root.y0 = 0;

  function collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach(collapse);
      d.children = null;
    }
  }

  //root.children.forEach(collapse); // start collapsed
  update(root);



function update(source) {

  // Compute the new tree layout.
  var nodes = tree.nodes(interactions);

  // Normalize for fixed-depth.
  // nodes.forEach(function(d) { d.y = d.depth * 90; });
  nodes.forEach(function(d) { 
    if (d.depth == 1) {
        d.y =  90
      } else if (d.depth == 2  ) {
        d.y =  250
      } else if (d.depth == 3  ) {
        d.y =  400
      } else {
        d.y =  d.depth*150
      }
    });

  var links = tree.links(nodes);

  // Update the nodes…
  var node = svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
      .attr("class", "node")
      // .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
      .on("click", click);

  nodeEnter.append("circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeEnter.append("text")
      // .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".31em")
      .attr("text-anchor", function(d) { return d.x < 180 ? "start" : "end"; })
      .attr("transform", function(d) { return d.x < 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
      .text(function(d) { return d.name; })
      .style("font-size", function(d) { if (d.depth<3) {return "12px"} else { return "8px" } })
      .style("fill", function(d) {
          if (d.color) {return "#111" } 
          else if (d.interactions > 0 && d.mutations_an > 0 && 1==2) {return "green" }
          else if (d.interactions > 0 && 1==2) {return "Olive" }
          else if (d.mutations_an > 0 && 1==2) {return "palegreen" }
          else {return "#222"}; })
      .style("fill-opacity", 1e-6);;

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      // .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 4.5)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      // .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
      .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
      .attr("class", "link")
      .style("stroke", function(d) { return d.target.color; })
      .style("stroke-width", function(d) { return 17-d.target.depth*d.target.depth; })
      .style("opacity", function(d) {
          if ((d.target.interactions > 0 && d.target.mutations_an > 0) || 1==1) {return 0.8 } //|| 1==1
          else if (d.target.interactions > 0) {return 0.5 }
          else if (d.target.mutations_an > 0) {return 0.5 }
          else {return 0.1}; })
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      });

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children on click.
function click(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}
</script>
{% endblock %}

{% block content %}
Coverage for class X

<div id=svg></div>
<div id=svg2></div>
<div id=svg3></div>
<div id=svg4></div>

<table width=1600>
<!-- {% for c,v in coverage.items %}
    <tr><td>{{c}}</td><td>I: {{v.interactions}} {{v.receptor_i}}</td><td>M: {{v.mutations}} {{v.receptor_m}}</td></tr>
        {% for lt,v in v.list.items %}
            <tr><td></td><td>{{lt}}</td><td>I: {{v.interactions}} {{v.receptor_i}}</td><td>M: {{v.mutations}} {{v.receptor_m}}</td></tr>
             {% for rf,v in v.list.items %} 
                <tr><td></td><td></td><td>{{rf}}</td><td>I: {{v.interactions}} {{v.receptor_i}}</td><td>M: {{v.mutations}} {{v.receptor_m}}</td></tr>  
                 {% for r,v in v.list.items %} 
                    <tr><td></td><td></td><td></td><td>{{r}}</td><td>I: {{v.interactions}}</td><td>M: {{v.mutations}}</td></tr>  
                 {% endfor %}
             {% endfor %}
        {% endfor %}
{% endfor %} -->
<tr>
    <th>ID</th>
    <th>Name</th>
    <th># receptors</th>
    <th>Interactions</th>
    <th>Rec. with int</th>
    <th>Fraction I</th>
    <th>Mutations</th>
    <th>Rec. with Mut</th>
    <th>Fraction M</th>
    <th>Mutations (an)</th>
    <th>Rec. with Mut (an)</th>
    <th>Fraction M (an)</th>
</tr>
<tr>
<th colspan="3"> Classes</th>
<tr>
{% for c,v in coverage.items %}
    <tr>
        <td>{{c}}</td>
        <td>{{v.name|safe}}</td>
        <td>{{v.receptor_t}}</td>
        <td>{{v.interactions}}</td>
        <td>{{v.receptor_i}}</td>
        <td>{{v.fraction_i|floatformat:"2"}}</td>
        <td>{{v.mutations}}</td>
        <td>{{v.receptor_m}}</td>
        <td>{{v.fraction_m|floatformat:"2"}}</td>
        <td>{{v.mutations_an}}</td>
        <td>{{v.receptor_m_an}}</td>
        <td>{{v.fraction_m_an|floatformat:"2"}}</td>
    </tr>
{% endfor %}

<tr>
<th colspan="3"> Ligand Type</th>
<tr>
{% for c,v in coverage.items %}
    {% for v in v.children %}
        <tr>
            <td>{{c}}_{{lt}}</td>
            <td>{{v.name|safe}}</td>
            <td>{{v.receptor_t}}</td>
            <td>{{v.interactions}}</td>
            <td>{{v.receptor_i}}</td>
            <td>{{v.fraction_i|floatformat:"2"}}</td>
            <td>{{v.mutations}}</td>
            <td>{{v.receptor_m}}</td>
            <td>{{v.fraction_m|floatformat:"2"}}</td>
            <td>{{v.mutations_an}}</td>
            <td>{{v.receptor_m_an}}</td>
            <td>{{v.fraction_m_an|floatformat:"2"}}</td>
        </tr>
    {% endfor %}
{% endfor %}

<tr>
<th colspan="3"> Receptor Family</th>
<tr>
{% for c,v in coverage.items %}
    {% for v in v.children %}
        {% for v in v.children %} 
                    <tr>
            <td>{{c}}_{{lt}}_{{rf}}</td>
            <td>{{v.name|safe}}</td>
            <td>{{v.receptor_t}}</td>
            <td>{{v.interactions}}</td>
            <td>{{v.receptor_i}}</td>
            <td>{{v.fraction_i|floatformat:"2"}}</td>
            <td>{{v.mutations}}</td>
            <td>{{v.receptor_m}}</td>
            <td>{{v.fraction_m|floatformat:"2"}}</td>
            <td>{{v.mutations_an}}</td>
            <td>{{v.receptor_m_an}}</td>
            <td>{{v.fraction_m_an|floatformat:"2"}}</td>
        </tr>
        {% endfor %}
    {% endfor %}
{% endfor %}

<tr>
<th colspan="3"> Receptor</th>
<tr>
{% for c,v in coverage.items %}
    {% for v in v.children %}
        {% for v in v.children %} 
            {% for v in v.children %} 
                    <tr>
            <td>{{c}}_{{lt}}_{{rf}}_{{r}}</td>
            <td>{{v.name|safe}}</td>
            <td>{{v.receptor_t}}</td>
            <td>{{v.interactions}}</td>
            <td>{{v.receptor_i}}</td>
            <td>{{v.fraction_i|floatformat:"2"}}</td>
            <td>{{v.mutations}}</td>
            <td>{{v.receptor_m}}</td>
            <td>{{v.fraction_m|floatformat:"2"}}</td>
            <td>{{v.mutations_an}}</td>
            <td>{{v.receptor_m_an}}</td>
            <td>{{v.fraction_m_an|floatformat:"2"}}</td>
        </tr>
        {% endfor %}
        {% endfor %}
    {% endfor %}
{% endfor %}

</table>
{% endblock %}